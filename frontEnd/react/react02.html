<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React Hooks 体系设计 | 绅士喵呜的技术博客</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="  ">
    <link rel="preload" href="/assets/css/0.styles.e7d7bc45.css" as="style"><link rel="preload" href="/assets/js/app.f09e1a8f.js" as="script"><link rel="preload" href="/assets/js/3.6380eba5.js" as="script"><link rel="preload" href="/assets/js/1.86ff7d31.js" as="script"><link rel="preload" href="/assets/js/84.91f0b5d9.js" as="script"><link rel="prefetch" href="/assets/js/10.5517d1b6.js"><link rel="prefetch" href="/assets/js/100.92371dc9.js"><link rel="prefetch" href="/assets/js/11.0573e311.js"><link rel="prefetch" href="/assets/js/12.0875f58d.js"><link rel="prefetch" href="/assets/js/13.71642ae4.js"><link rel="prefetch" href="/assets/js/14.36f8acdb.js"><link rel="prefetch" href="/assets/js/15.6215165a.js"><link rel="prefetch" href="/assets/js/16.485c8436.js"><link rel="prefetch" href="/assets/js/17.03710596.js"><link rel="prefetch" href="/assets/js/18.1935d804.js"><link rel="prefetch" href="/assets/js/19.1389efb6.js"><link rel="prefetch" href="/assets/js/20.083b5e26.js"><link rel="prefetch" href="/assets/js/21.6074112f.js"><link rel="prefetch" href="/assets/js/22.7ee932d9.js"><link rel="prefetch" href="/assets/js/23.b5b2417f.js"><link rel="prefetch" href="/assets/js/24.16e24b97.js"><link rel="prefetch" href="/assets/js/25.c0f615e7.js"><link rel="prefetch" href="/assets/js/26.54e45f38.js"><link rel="prefetch" href="/assets/js/27.1a2c9280.js"><link rel="prefetch" href="/assets/js/28.b770ec38.js"><link rel="prefetch" href="/assets/js/29.acca8bd0.js"><link rel="prefetch" href="/assets/js/30.d2532d72.js"><link rel="prefetch" href="/assets/js/31.eb2b3d90.js"><link rel="prefetch" href="/assets/js/32.6565c348.js"><link rel="prefetch" href="/assets/js/33.c7bc65b2.js"><link rel="prefetch" href="/assets/js/34.1bf2f3da.js"><link rel="prefetch" href="/assets/js/35.d3385f69.js"><link rel="prefetch" href="/assets/js/36.5cfe3ec3.js"><link rel="prefetch" href="/assets/js/37.26aef80a.js"><link rel="prefetch" href="/assets/js/38.a35b1680.js"><link rel="prefetch" href="/assets/js/39.8a99a996.js"><link rel="prefetch" href="/assets/js/4.8ca4a540.js"><link rel="prefetch" href="/assets/js/40.3ccc91a6.js"><link rel="prefetch" href="/assets/js/41.d6b84276.js"><link rel="prefetch" href="/assets/js/42.bf751eb9.js"><link rel="prefetch" href="/assets/js/43.410217ff.js"><link rel="prefetch" href="/assets/js/44.1500d4ec.js"><link rel="prefetch" href="/assets/js/45.37818d2d.js"><link rel="prefetch" href="/assets/js/46.e865b48f.js"><link rel="prefetch" href="/assets/js/47.e854ab11.js"><link rel="prefetch" href="/assets/js/48.28bcbd91.js"><link rel="prefetch" href="/assets/js/49.cb7462d2.js"><link rel="prefetch" href="/assets/js/5.3153c171.js"><link rel="prefetch" href="/assets/js/50.2217c9c1.js"><link rel="prefetch" href="/assets/js/51.cfadb2b8.js"><link rel="prefetch" href="/assets/js/52.752ecedc.js"><link rel="prefetch" href="/assets/js/53.7c8e434c.js"><link rel="prefetch" href="/assets/js/54.ec8b8cb9.js"><link rel="prefetch" href="/assets/js/55.e86e5fbd.js"><link rel="prefetch" href="/assets/js/56.19995147.js"><link rel="prefetch" href="/assets/js/57.c3f8dd98.js"><link rel="prefetch" href="/assets/js/58.d0d3ab90.js"><link rel="prefetch" href="/assets/js/59.04d9b9ea.js"><link rel="prefetch" href="/assets/js/6.f20cbf4e.js"><link rel="prefetch" href="/assets/js/60.1b51b1c9.js"><link rel="prefetch" href="/assets/js/61.ca052798.js"><link rel="prefetch" href="/assets/js/62.dbb692ec.js"><link rel="prefetch" href="/assets/js/63.f254ed9a.js"><link rel="prefetch" href="/assets/js/64.f27c1117.js"><link rel="prefetch" href="/assets/js/65.da43f37a.js"><link rel="prefetch" href="/assets/js/66.ac41ad1b.js"><link rel="prefetch" href="/assets/js/67.139f543f.js"><link rel="prefetch" href="/assets/js/68.9281c085.js"><link rel="prefetch" href="/assets/js/69.bec927a5.js"><link rel="prefetch" href="/assets/js/7.08bf542b.js"><link rel="prefetch" href="/assets/js/70.db0613c6.js"><link rel="prefetch" href="/assets/js/71.0c3d0498.js"><link rel="prefetch" href="/assets/js/72.aee3f326.js"><link rel="prefetch" href="/assets/js/73.76f9ab8f.js"><link rel="prefetch" href="/assets/js/74.03ec551c.js"><link rel="prefetch" href="/assets/js/75.96bd35fd.js"><link rel="prefetch" href="/assets/js/76.8eea9d5c.js"><link rel="prefetch" href="/assets/js/77.13908ef5.js"><link rel="prefetch" href="/assets/js/78.609cb13a.js"><link rel="prefetch" href="/assets/js/79.0d4df250.js"><link rel="prefetch" href="/assets/js/8.215181eb.js"><link rel="prefetch" href="/assets/js/80.73ae2e4f.js"><link rel="prefetch" href="/assets/js/81.3927ddde.js"><link rel="prefetch" href="/assets/js/82.86b457e2.js"><link rel="prefetch" href="/assets/js/83.93f4c999.js"><link rel="prefetch" href="/assets/js/85.0e943352.js"><link rel="prefetch" href="/assets/js/86.82041574.js"><link rel="prefetch" href="/assets/js/87.5dd34590.js"><link rel="prefetch" href="/assets/js/88.e36c88ec.js"><link rel="prefetch" href="/assets/js/89.ded599d3.js"><link rel="prefetch" href="/assets/js/9.89288b36.js"><link rel="prefetch" href="/assets/js/90.60714017.js"><link rel="prefetch" href="/assets/js/91.06074398.js"><link rel="prefetch" href="/assets/js/92.26998e97.js"><link rel="prefetch" href="/assets/js/93.3bcbb0d7.js"><link rel="prefetch" href="/assets/js/94.bf2a69b4.js"><link rel="prefetch" href="/assets/js/95.dd3b1169.js"><link rel="prefetch" href="/assets/js/96.26bbe59b.js"><link rel="prefetch" href="/assets/js/97.b883aa89.js"><link rel="prefetch" href="/assets/js/98.cc07f12e.js"><link rel="prefetch" href="/assets/js/99.d38481a5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e7d7bc45.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-dad8a512><div data-v-dad8a512><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-dad8a512 data-v-dad8a512><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-64685f0e data-v-dad8a512 data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>绅士喵呜的技术博客</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>hentaimiao</span>
            
          <!---->
          2020
        </a></span></div></div> <div class="hide" data-v-dad8a512><header class="navbar" data-v-dad8a512><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">绅士喵呜的技术博客</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/backEnd/" class="nav-link"><i class="iconfont undefined"></i>
  backEnd
</a></li><li class="dropdown-item"><!----> <a href="/categories/frontEnd/" class="nav-link"><i class="iconfont undefined"></i>
  frontEnd
</a></li><li class="dropdown-item"><!----> <a href="/categories/software/" class="nav-link"><i class="iconfont undefined"></i>
  software
</a></li><li class="dropdown-item"><!----> <a href="/categories/http/" class="nav-link"><i class="iconfont undefined"></i>
  http
</a></li><li class="dropdown-item"><!----> <a href="/categories/建造中/" class="nav-link"><i class="iconfont undefined"></i>
  建造中
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="iconfont undefined"></i>
  react
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      前端学习
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>基础</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontEnd/html/" class="nav-link"><i class="iconfont undefined"></i>
  HTML
</a></li><li class="dropdown-subitem"><a href="/frontEnd/css/" class="nav-link"><i class="iconfont undefined"></i>
  CSS
</a></li><li class="dropdown-subitem"><a href="/frontEnd/js/" class="nav-link"><i class="iconfont undefined"></i>
  JS
</a></li><li class="dropdown-subitem"><a href="/frontEnd/es6/" class="nav-link"><i class="iconfont undefined"></i>
  ES6
</a></li></ul></li><li class="dropdown-item"><h4>动画</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontEnd/greensock/" class="nav-link"><i class="iconfont undefined"></i>
  GreenSock
</a></li></ul></li><li class="dropdown-item"><h4>框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontEnd/vue/" class="nav-link"><i class="iconfont undefined"></i>
  Vue
</a></li><li class="dropdown-subitem"><a href="/frontEnd/react/" class="nav-link router-link-active"><i class="iconfont undefined"></i>
  React
</a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontEnd/axios/" class="nav-link"><i class="iconfont undefined"></i>
  Axios
</a></li><li class="dropdown-subitem"><a href="/frontEnd/TypeScript/" class="nav-link"><i class="iconfont undefined"></i>
  TypeScript
</a></li><li class="dropdown-subitem"><a href="/webpack/" class="nav-link"><i class="iconfont undefined"></i>
  Webpack
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      后端探索
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/backEnd/http/" class="nav-link"><i class="iconfont undefined"></i>
  http
</a></li><li class="dropdown-item"><!----> <a href="/backEnd/node/" class="nav-link"><i class="iconfont undefined"></i>
  node
</a></li><li class="dropdown-item"><!----> <a href="/other/" class="nav-link"><i class="iconfont undefined"></i>
  其他
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      软件开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/backEnd/git/" class="nav-link"><i class="iconfont undefined"></i>
  Git版本控制
</a></li><li class="dropdown-item"><!----> <a href="/development/agile/" class="nav-link"><i class="iconfont undefined"></i>
  敏捷开发
</a></li></ul></div></div> <a href="https://github.com/hentai-miao/blog-vuepress" target="_blank" rel="noopener noreferrer" class="repo-link"><i class="iconfont reco-github"></i>
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask" data-v-dad8a512></div> <aside class="sidebar" data-v-dad8a512><div class="personal-info-wrapper" data-v-ca798c94 data-v-dad8a512><img src="/avatar.jpg" alt="author-avatar" class="personal-img" data-v-ca798c94> <h3 class="name" data-v-ca798c94>
    hentaimiao
  </h3> <div class="num" data-v-ca798c94><div data-v-ca798c94><h3 data-v-ca798c94>66</h3> <h6 data-v-ca798c94>Article</h6></div> <div data-v-ca798c94><h3 data-v-ca798c94>18</h3> <h6 data-v-ca798c94>Tag</h6></div></div> <hr data-v-ca798c94></div> <nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont reco-category"></i>
      分类
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/backEnd/" class="nav-link"><i class="iconfont undefined"></i>
  backEnd
</a></li><li class="dropdown-item"><!----> <a href="/categories/frontEnd/" class="nav-link"><i class="iconfont undefined"></i>
  frontEnd
</a></li><li class="dropdown-item"><!----> <a href="/categories/software/" class="nav-link"><i class="iconfont undefined"></i>
  software
</a></li><li class="dropdown-item"><!----> <a href="/categories/http/" class="nav-link"><i class="iconfont undefined"></i>
  http
</a></li><li class="dropdown-item"><!----> <a href="/categories/建造中/" class="nav-link"><i class="iconfont undefined"></i>
  建造中
</a></li><li class="dropdown-item"><!----> <a href="/categories/react/" class="nav-link"><i class="iconfont undefined"></i>
  react
</a></li></ul></div></div><div class="nav-item"><a href="/tag/" class="nav-link"><i class="iconfont reco-tag"></i>
  标签
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      前端学习
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>基础</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontEnd/html/" class="nav-link"><i class="iconfont undefined"></i>
  HTML
</a></li><li class="dropdown-subitem"><a href="/frontEnd/css/" class="nav-link"><i class="iconfont undefined"></i>
  CSS
</a></li><li class="dropdown-subitem"><a href="/frontEnd/js/" class="nav-link"><i class="iconfont undefined"></i>
  JS
</a></li><li class="dropdown-subitem"><a href="/frontEnd/es6/" class="nav-link"><i class="iconfont undefined"></i>
  ES6
</a></li></ul></li><li class="dropdown-item"><h4>动画</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontEnd/greensock/" class="nav-link"><i class="iconfont undefined"></i>
  GreenSock
</a></li></ul></li><li class="dropdown-item"><h4>框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontEnd/vue/" class="nav-link"><i class="iconfont undefined"></i>
  Vue
</a></li><li class="dropdown-subitem"><a href="/frontEnd/react/" class="nav-link router-link-active"><i class="iconfont undefined"></i>
  React
</a></li></ul></li><li class="dropdown-item"><h4>其他</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/frontEnd/axios/" class="nav-link"><i class="iconfont undefined"></i>
  Axios
</a></li><li class="dropdown-subitem"><a href="/frontEnd/TypeScript/" class="nav-link"><i class="iconfont undefined"></i>
  TypeScript
</a></li><li class="dropdown-subitem"><a href="/webpack/" class="nav-link"><i class="iconfont undefined"></i>
  Webpack
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      后端探索
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/backEnd/http/" class="nav-link"><i class="iconfont undefined"></i>
  http
</a></li><li class="dropdown-item"><!----> <a href="/backEnd/node/" class="nav-link"><i class="iconfont undefined"></i>
  node
</a></li><li class="dropdown-item"><!----> <a href="/other/" class="nav-link"><i class="iconfont undefined"></i>
  其他
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="iconfont undefined"></i>
      软件开发
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/backEnd/git/" class="nav-link"><i class="iconfont undefined"></i>
  Git版本控制
</a></li><li class="dropdown-item"><!----> <a href="/development/agile/" class="nav-link"><i class="iconfont undefined"></i>
  敏捷开发
</a></li></ul></div></div> <a href="https://github.com/hentai-miao/blog-vuepress" target="_blank" rel="noopener noreferrer" class="repo-link"><i class="iconfont reco-github"></i>
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav> <ul class="sidebar-links"><li><a href="/frontEnd/react/" aria-current="page" class="sidebar-link">React.js 可视化编辑工具</a></li><li><a href="/frontEnd/react/react01.html" class="sidebar-link">React 整理手册</a></li><li><a href="/frontEnd/react/react02.html" aria-current="page" class="active sidebar-link">React Hooks 体系设计</a></li><li><a href="/frontEnd/react/react03.html" class="sidebar-link">Immer.js 精读</a></li><li><a href="/frontEnd/react/react04.html" class="sidebar-link">使用 Immer 优化 Reducer</a></li><li><a href="/frontEnd/react/react05.html" class="sidebar-link">使用 useReducer 和 TypeScript 优化 React 上下文</a></li><li><a href="/frontEnd/react/react06.html" class="sidebar-link">react 中防抖函数的实现</a></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-64685f0e data-v-dad8a512><h3 class="title" style="display:none;" data-v-64685f0e data-v-64685f0e>React Hooks 体系设计</h3> <!----> <label id="box" class="inputBox" style="display:none;" data-v-64685f0e data-v-64685f0e><input type="password" value="" data-v-64685f0e> <span data-v-64685f0e>Konck! Knock!</span> <button data-v-64685f0e>OK</button></label> <div class="footer" style="display:none;" data-v-64685f0e data-v-64685f0e><span data-v-64685f0e><i class="iconfont reco-theme" data-v-64685f0e></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-64685f0e>vuePress-theme-reco</a></span> <span data-v-64685f0e><i class="iconfont reco-copyright" data-v-64685f0e></i> <a data-v-64685f0e><span data-v-64685f0e>hentaimiao</span>
            
          <!---->
          2020
        </a></span></div></div> <div data-v-dad8a512><main class="page"><div class="page-title" style="display:none;"><h1>React Hooks 体系设计</h1> <div data-v-3b7f5bdf><i class="iconfont reco-account" data-v-3b7f5bdf><span data-v-3b7f5bdf>hentaimiao</span></i> <i class="iconfont reco-date" data-v-3b7f5bdf><span data-v-3b7f5bdf>2020-09-06</span></i> <!----> <i class="iconfont reco-tag tags" data-v-3b7f5bdf><span class="tag-item" data-v-3b7f5bdf>React</span></i></div></div> <div class="theme-reco-content content__default" style="display:none;"><p>React Hooks 是 React 框架内的逻辑复用形式，因为其轻量、易编写的形态，必然会逐渐成为一种前端开发主流。但是在实际开发过程中，大部分的开发者对于 Hooks 的使用过于粗暴，缺乏设计感和复用性。
</p> <p>优质的专栏，把它整合一遍：https://zhuanlan.zhihu.com/fefame</p> <h2 id="不忘初心-始于分层"><a href="#不忘初心-始于分层" aria-hidden="true" class="header-anchor">#</a> 不忘初心，始于分层</h2> <p>要知道之所以使用框架，一开始就是为了代码结构能够清晰明了</p> <p>软件工程的经典论述：</p> <blockquote><p>We can solve any problem by introducting an extra level of indirection</p> <p>没有什么问题是加一个层解决不了的。</p></blockquote> <p>这个论述自软件工程诞生起，至今依然是成立的，但要使之成立就必须有一个大前提：我们有分层</p> <p>React 内置的 Hooks 提供了基础的能力，虽然本质上它也有一些分层，比如：</p> <ul><li><code>useStaste</code> 是基于 <code>useReducer</code> 的简化版本</li> <li><code>useMemo</code> 和 <code>useCallback</code> 事实上可以基于 <code>useRef</code> 实现</li></ul> <p>但是在实际应用时，我们可以将其视为一层，即基础的底层</p> <p>因此，我们在实际的应用开发中，单纯地在组件里组合使用内置的 <code>hook</code> ，无疑是一种不分层的粗暴使用形式，这仅仅在表象上使用了 <code>hook</code> ，而无法基于 <code>hook</code> 达到逻辑复用的目标。</p> <h3 id="状态的分层设计"><a href="#状态的分层设计" aria-hidden="true" class="header-anchor">#</a> 状态的分层设计</h3> <p>分层的形式固然千千万万五花八门，我选择了一种更为贴近传统，更能表达程序的本质的方法，以此将 <code>hook</code> 在纵向分为 6 个层，自底向上依次是：</p> <ol><li>最底层的内置 <code>hook</code>，不需要自己实现，官方直接提供</li> <li>简化状态更新方式的 <code>hook</code>，比较经典的是引入 <code>immer</code> 来达到更方便地进行不可变更新的目的</li> <li>引入「状态 + 行为」的概念，通过声明状态结构与相应行为快速创建一个完整上下文</li> <li>对常见数据结构的操作进行封装，如数组的操作</li> <li>针对通用业务场景进行封装，如分页的列表、滚动加载的列表、多选等</li> <li>实际面向业务的实现</li></ol> <p>需要注意的是，这边仅仅提到了对状态的分层设计，事实上有大量的 <code>hook</code> 是游离于状态之外的，如基于 <code>useEffect</code> 的 <code>useDocumentSize</code>，或是基于 <code>useRef</code> 的 <code>usePreviousValue</code>、<code>useStableMemo</code> 等，这些 <code>hook</code> 是更加零散。独立的形态</p> <h3 id="使用-immer-更新状态"><a href="#使用-immer-更新状态" aria-hidden="true" class="header-anchor">#</a> 使用 <code>immer</code> 更新状态</h3> <p>在第二层中，我们需要解决的问题是 React 要求的不可变数据更新有一定的操作复杂性，比如当我们需要更新对象的一个属性的时候，就需要</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> newValue <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>oldValue<span class="token punctuation">,</span>
  foo<span class="token punctuation">:</span> newFoo<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这还只是一个简单对象，如果遇到复杂一些的对象，就大概率可能出现这样的情况：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> newValue <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>oldValue<span class="token punctuation">,</span>
  foo<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>oldValue<span class="token operator">?</span><span class="token punctuation">.</span>foo<span class="token punctuation">,</span>
    bar<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>oldValue<span class="token operator">?</span><span class="token punctuation">.</span>foo<span class="token operator">?</span><span class="token punctuation">.</span>bar<span class="token punctuation">,</span>
      alice<span class="token punctuation">:</span> newAlice<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>数组也不怎么容易，比如我想删除一个元素，就要这么来：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> newArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>oldArray<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">...</span>oldArray<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre></div><p>这些都是基于原有对象，进行数据的更新。</p> <p>要解决这一些系列问题，我们可以使用 <code>immer</code>，利用 <code>proxy</code> 数据劫持的特性，将可变的数据更新映射为不可变的操作</p> <p>状态管理额基础 <code>hook</code> 是 <code>useState</code> 和 <code>useReducer</code>，因此我们能封装成：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> setStatee<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useImmerState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token punctuation">:</span> <span class="token punctuation">{</span> bar<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> s<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">// 直接进行可变更新</span>
<span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token punctuation">:</span> <span class="token punctuation">{</span> bar<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 保留直接更新值的功能</span>
</code></pre></div><p>以及：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>state<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useImmerReducer</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'ADD'</span><span class="token punctuation">:</span>
            state<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar <span class="token operator">+=</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token string">'SUBTRACT'</span><span class="token punctuation">:</span>
            state<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>bar <span class="token operator">-=</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>foo<span class="token punctuation">:</span> <span class="token punctuation">{</span>bar<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'ADD'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>payload<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这一部分并没有太多的工作（<code>immer</code> 的 <code>TS</code> 类型是真的难写），但是提供了非常方便的状态更新能力，也便于在它之上的所有层的实现</p> <h3 id="状态与行为的封装"><a href="#状态与行为的封装" aria-hidden="true" class="header-anchor">#</a> 状态与行为的封装</h3> <p>组件的开发，或者说绝大部分业务的开发，逃不出”一个状态 + 一系列行为“这个模式，而且行为与状态的结构是强相关的。这个模式在面向对象里我们称之为<strong>类</strong>：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>
  name <span class="token operator">=</span> <span class="token string">''</span>
  age <span class="token operator">=</span> <span class="token number">0</span>

  <span class="token function">birthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">++</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而在 <code>hook</code>中，我们会这么做：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> SetAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> birthday <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">age</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> age <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>age<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>这样子会出现一些问题：</p> <ol><li>太多的 <code>useState</code> 和 <code>useCallback</code> 调用，重复的编码工作</li> <li>如果不仔细阅读代码，很难找到状态与行为的对应关系</li></ol> <p>因此需要一个 <code>hook</code> 来帮助实现「一个状态」和「针对这个状态的行为」合并在一起：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> userMethods <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">birthday</span><span class="token punctuation">(</span><span class="token parameter">user</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    user<span class="token punctuation">.</span>age<span class="token operator">++</span> <span class="token comment">// 利用了immer的能力</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>user<span class="token punctuation">,</span> methods<span class="token punctuation">,</span> setUser<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useMethods</span><span class="token punctuation">(</span>userMethods<span class="token punctuation">,</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

methods<span class="token punctuation">.</span><span class="token function">birthday</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>可以看到，这样的声明十分接近面向对象的形态，有部分 React 开发者在粗浅地了解了函数式编程后，激进地反对面向对象，这显然是不可取的，面向对象依然是一种很好的封装和职责边界划分的形态，不一定要以其表面形态去实现，却也不可丢了其内在思想</p> <h3 id="数据结构的抽象"><a href="#数据结构的抽象" aria-hidden="true" class="header-anchor">#</a> 数据结构的抽象</h3> <p>有了 <code>useMethods</code> 之后，我们已经可以快速地使用任何类型和结构的状态与 <code>hook</code> 整合，我们一定会意识到，有一部分状态类型是业务无关的，是全天下所有开发者所通用的，比如最基础的数据类型 <code>number</code>、<code>string</code>、<code>Array</code> 等</p> <p>在数据结构的封装上，我们依然会面对几个核心问题：</p> <ol><li>部分数据结构的不可变操作相当复杂，比如不可变地实现 <code>Array#splice</code>，好在有 <code>immer</code> 合理地解决了这部分问题</li> <li>部分操作的语义会发生变化，<code>setState</code> 最典型的是么有返回值，因此 <code>Array#pop</code> 只能产生「移除最后一个元素」的行为，而无法将移除的元素返回</li> <li>部分类型是天生可变的，如 <code>Set</code> 和 <code>Map</code>，将之映射到不可变需要额外的工作</li></ol> <p>针对常用数据结构的抽象，在试图解决这些问题（第二个问题还真解决不了）的同时，也能扩展一些行为，比如：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>list<span class="token punctuation">,</span> methods<span class="token punctuation">,</span> setList<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useArray</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token keyword">interface</span> <span class="token class-name">ArrayMethods</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token class-name">T</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text"> </span><span class="token punctuation">{</span>
  <span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">unshift</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">slice</span><span class="token punctuation">(</span>start<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> end<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> count<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> <span class="token operator">...</span>items<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">remove</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">removeAt</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">insertAt</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> item<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">concat</span><span class="token punctuation">(</span>item<span class="token punctuation">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">replace</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> to<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> to<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">replaceAt</span><span class="token punctuation">(</span>index<span class="token punctuation">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> item<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">filter</span><span class="token punctuation">(</span><span class="token function-variable function">predicate</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> index<span class="token punctuation">:</span> <span class="token builtin">number</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">boolean</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">union</span><span class="token punctuation">(</span>array<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">intersect</span><span class="token punctuation">(</span>array<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">difference</span><span class="token punctuation">(</span>array<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">sort</span><span class="token punctuation">(</span>compare<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token builtin">number</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
  <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">void</span>
<span class="token punctuation">}</span><span class="token plain-text">
</span></code></pre></div><p>而诸如 <code>useSet</code> 和 <code>useMap</code> 则会在每次更新时做一次对象复制的操作，强制实现状态的不可变。</p> <p>社区的 <code>hook</code> 库中，很少看到有单独一个层实现数据结构的封装，实在是一种遗憾（不要封装啊喂），截止到今日，大致<code>useNumber</code>、<code>useArray</code>、<code>useSet</code>、<code>useMap</code>、<code>useBoolean</code>是已然实现的，其中还衍生出<code>useToggle</code>这样场景更狭窄的实现。而<code>useString</code>、<code>useFunction</code>和<code>useObject</code>能够提供什么能力还有待观察。</p> <h3 id="通用场景"><a href="#通用场景" aria-hidden="true" class="header-anchor">#</a> 通用场景</h3> <p>在有了基本的数据结构后，可以对场景进行封装，这一点在阿里的<a href="https://link.zhihu.com/?target=https%3A//github.com/umijs/hooks" target="_blank" rel="noopener noreferrer">@umijs/hooks<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>体现的比较多，如<code>useVirtualList</code>就是一个价值非常大的场景的封装。</p> <p>需要注意的是，场景的封装不应与组件库耦合，它应当是业务与组件之间的桥梁，不同的组件库使用相同的 <code>hook</code> 实现不同的界面，这才是一个理想的模式：</p> <ul><li><code>useTransfer</code>实现左右双列表选择的能力</li> <li><code>useSelection</code>实现列表上单选、多选、范围选择的能力</li> <li><code>useScrollToLoad</code>实现滚动加载的能力</li></ul> <p>通用场景的封装非常的多，它的灵感可以来源于某一个组件库，也可以由团队的业务沉淀。一个充分的场景封装 hook 集合会是未来 React 业务开发的效率的关键之一。</p> <h3 id="分层总结"><a href="#分层总结" aria-hidden="true" class="header-anchor">#</a> 分层总结</h3> <p>总而言之，在业务中暴力地直接使用 <code>useState</code> 等 <code>hook</code> 并不是一个值得提倡的方式，而针对状态这一块，精细地做一下分层，并在每个层提供相应的能力，是有助于组织 <code>hook</code> 库并赋能于业务研发效率的</p> <h3 id="hook-集合"><a href="#hook-集合" aria-hidden="true" class="header-anchor">#</a> hook 集合</h3> <p><a href="https://link.zhihu.com/?target=https%3A//github.com/ecomfe/react-hooks" target="_blank" rel="noopener noreferrer">@huse<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的 hook 集合，同样应用了分层的理念，也欢迎提出相应的需求，将于近期发布一个版本。</p> <p>https://github.com/ecomfe/react-hooks</p> <h2 id="状态管理-状态粒度"><a href="#状态管理-状态粒度" aria-hidden="true" class="header-anchor">#</a> 状态管理，状态粒度</h2> <p>状态无论什么时候都是 react 的重中之重</p> <p>在有了 <code>useState</code> 之后，会发现状态被天生地拆散了，比如这是一个曾经的类组件：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">class</span> <span class="token class-name">TodoList</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    dataSource<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    isLoading<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    filterText<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
    filterType<span class="token punctuation">:</span> <span class="token string">'all'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>放到 hooks 上面，大概率就是这个样子：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">TodoList</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>dataSource<span class="token punctuation">,</span> setDataSource<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>isLoading<span class="token punctuation">,</span> setLoading<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>filterText<span class="token punctuation">,</span> filterByText<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>filterType<span class="token punctuation">,</span> filterByType<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'all'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>老实说这算好的了，至少还搞了发起名的艺术，没有啥都叫 <code>setFooBar</code></p> <p>上面的这个转换方式无疑是正确的，不过现实并不总这么友好，状态拆分的时候，容易出现粒度控制不好的情况</p> <h3 id="粒度过细"><a href="#粒度过细" aria-hidden="true" class="header-anchor">#</a> 粒度过细</h3> <p>如果按照标准的每一个状态对应一个 <code>useState</code> 的做法，自然是逻辑上正确的，但它容易造成状态粒度过细的问题</p> <p>讲一个故事：</p> <blockquote><p>做一个表格，带一个选中功能，其中一个点是“按住 SHIFT 的同时点击一行可以选中一个区域”。</p></blockquote> <p>为了实现这个功能，我们需要 2 套逻辑：</p> <ol><li>当点击一行时，选中这一行</li> <li>按 SHIFT 点击时，把上一次选中（或第一行）到当前行都选中</li></ol> <p>从这个场景我们能分析出一个结论：点击一行的时候，除了选中它，还需要记录最后一次选中的行为。为了简化这个模型，代码中先不管“取消选择”的效果：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">SelectableList</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>selection<span class="token punctuation">,</span> setSelection<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>lastSelected<span class="token punctuation">,</span> setLastSelected<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> selectLine <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
  	<span class="token parameter">index</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setSelection</span><span class="token punctuation">(</span><span class="token parameter">lines</span> <span class="token operator">=&gt;</span> lines<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">setLastSelected</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>】
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>仔细看 <code>useCallback</code> 中的部分，我们能看到它会连续调用 2 个状态的更新，这会造成什么情况呢？每一次状态更新都触发一次渲染，会导致多次渲染的浪费嘛？</p> <p>答案不好说，如果这件事发生在 React 管理的事件中，则更新会被合并起来，如果发生在其他场合（比如说异步结束时），则会使得 React 触发多次渲染。</p> <p>一个相关示例：<a href="https://link.zhihu.com/?target=https%3A//codesandbox.io/s/set-multiple-state-in-callback-6m6vd" target="_blank" rel="noopener noreferrer">CodeSandbox 示例<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>但是这里我们着重讨论代码的组织和可读性问题</p> <p>class 类组件时代，代码是这样的：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">class</span> <span class="token class-name">SelectableList</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">selectLine</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
      selection<span class="token punctuation">:</span> state<span class="token punctuation">.</span>selection<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span>
      lastSelected<span class="token punctuation">:</span> index<span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而不会这么写：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">class</span> <span class="token class-name">SelectableList</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">selectLine</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> selection<span class="token punctuation">:</span> state<span class="token punctuation">.</span>selection<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> lastSelected<span class="token punctuation">:</span> index <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不否认 class 时代状态的集中管理是过于粗放的，但那个时代的状态更新粒度基本是没有问题的，所以在使用 hook 的时候不哟啊太过暴力的拆分状态，过于细粒度的拆分状态会导致代码阅读者难以理解状态间的关系，五星提升代码维护的难度</p> <h3 id="使用-reducer-管理状态更新"><a href="#使用-reducer-管理状态更新" aria-hidden="true" class="header-anchor">#</a> 使用 Reducer 管理状态更新</h3> <p>现在搞清楚了状态粒度太细是不好的，所以不妨碍奖上面示例的状态重新再合并回来：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token constant">DEFAULT_SELECTION_STATE</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  selection<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  lastSelected<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">SelectableList</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>selectionState<span class="token punctuation">,</span> setSelectionState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_SELECTION_STATE</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> selectLine <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token function-variable function">updater</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> selection <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        selection<span class="token punctuation">:</span> selection<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">,</span>
        lastSelected<span class="token punctuation">:</span> index<span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">setSelectionState</span><span class="token punctuation">(</span>updater<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>没什么难度，确实没什么难度</p> <p>但是这种做法，依然会有一个问题：状态的更新与状态的声明距离过远。在这个例子中很难看出来，状态声明之后立刻旧有 <code>useCallback</code> 的调用去说明如何更新它。但是在实际编码中，我们很容易遇到状态的声明在第 1 行，而状态的更新在第 40+ 行这种情况，甚至是最终 JSX 中的某个箭头函数中。</p> <p>在这样的代码中，阅读者想要搞清楚一个状态如何被使用、如何更新时十分困难的，这不仅降低了代码的可维护性，还给代码阅读者很大的挫败感，久而久之谁也不想接手这样的代码。</p> <p>解决这个问题通常有两种方法：</p> <ol><li>把状态和更新封装到自定义的 Hook 当中去，比如就叫 <code>useSelection</code></li> <li>使用 <code>useReducer</code></li></ol> <p>第一种方法必不用说，能不能找到合适的粒度来实现自定义 hoook 就是对开发者素质的考研。但不少时候自定义 hook 作为一种解决方案还是过于重量级，虽然它仅仅是一个函数，但是依然需要阅读者去理解输入输出，使用 <code>TypeScript</code> 还可能造成类型定义上的额外工作。</p> <p>使用 <code>useReducer</code> 可以在不少轻量级的场景中快速地将状态声明和状态更新放在一起，比如上面的例子可以这样改造：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">SelectableList</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>selectionState<span class="token punctuation">,</span> dispatchSelectionState<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token parameter">state<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">switch</span> <span class="token punctuation">(</span>action<span class="token punctuation">.</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token string">'select'</span><span class="token punctuation">:</span>
          <span class="token keyword">return</span> <span class="token punctuation">{</span>
            selection<span class="token punctuation">:</span> state<span class="token punctuation">.</span>selection<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>payload<span class="token punctuation">)</span><span class="token punctuation">,</span>
            lastSelected<span class="token punctuation">:</span> action<span class="token punctuation">.</span>payload<span class="token punctuation">,</span>
          <span class="token punctuation">}</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span>
          <span class="token keyword">return</span> state
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span> selection<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lastSelected<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，通过 <code>useReducer</code> 我们传递一个函数，这个函数清晰地表达了 <code>select</code> 这个类型的操作，以及对应的状态更新。<code>useReducer</code> 的第二个参数也很好地说明了状态的结构。</p> <p>当然如果我们使用 <code>useImmer</code> 或者 <code>useMethods</code> 会更容易实现：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">SelectList</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>selectionState<span class="token punctuation">,</span> <span class="token punctuation">{</span>select<span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useMethods</span><span class="token punctuation">(</span>
  	methods<span class="token punctuation">,</span>'
    <span class="token punctuation">{</span>selection<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> lastSelected<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span>'
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="状态过粗"><a href="#状态过粗" aria-hidden="true" class="header-anchor">#</a> 状态过粗</h3> <p>反过来，状态也可能太粗，比如我们硬是将整个 <code>class</code> 的状态转移到一个 <code>useState</code> 中：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token constant">DEFAULT_STATE</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  dataSource<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  isLoading<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  filterText<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
  filterType<span class="token punctuation">:</span> <span class="token string">'all'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样子写和 <code>class</code> 组件没两样，不建议这么干 ，当然数据流也许看起来会更清晰那么一点。</p> <p>我们来考虑一下状态过粗的代价：</p> <p>不过在此依然需要提一下状态过粗的代价，试想这样的组件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">UserInfo</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> <span class="token punctuation">{</span>
        isBaseLoading<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        isDetailLoading<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        baseInfo<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        detailInfo<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
        isDetailVisible<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">async</span> <span class="token function-variable function">showDetail</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>detailInfo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>isDetailVisible<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>isDetailLoading<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">const</span> detail <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                isDetailLoading<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
                detailInfo<span class="token punctuation">:</span> detail<span class="token punctuation">,</span>
                isDetailVisible<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后我们还有一个这样的组件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">TodoList</span> <span class="token punctuation">{</span>
  state <span class="token operator">=</span> <span class="token punctuation">{</span>
    filterText<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>
    filterType<span class="token punctuation">:</span> <span class="token string">'all'</span><span class="token punctuation">,</span>
    showFilterPanel<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>

  <span class="token function-variable function">toggleFilterPanel</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setStae</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> showFilterPanel<span class="token punctuation">:</span> <span class="token operator">!</span>s<span class="token punctuation">.</span>showFilterPanel <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这有什么问题呢？仔细去看 2 个组件，我们会发现它们其实是有共同的部分的：</p> <ol><li>有一个能展开/收起的状态，一个叫<code>isDetailVisible</code>一个叫<code>showFilterPanel</code>。</li> <li>有多个和异步过程有关的状态，比如<code>isBaseLoading</code>和<code>isDetailLoading</code>。</li> <li>有异步状态与结果的成对出现，比如<code>isBaseLoading</code>配对<code>baseInfo</code>，<code>isDetailLoading</code>配对<code>detailInfo</code>。</li></ol> <p>但能得到这些结论，很大程度上归功于我给的代码过于精简，以及给了阅读者明确的“去发现”的目的。</p> <p>试想你有一个超过 10 万行代码的项目，里面有 800 多个组件，有些组件有 1200 多行，你作为一个技术负责人空降到项目中，有信心去发现这些东西吗？反正我作为一个所谓的高 T，很实诚地说我做不到。</p> <p>所以状态粒度过粗的问题就在于，它会隐藏掉可以复用的状态，让人不知不觉通过“行云流水地重复编码”来实现功能，离复用和精简越来越远。</p> <p>当然，有时候保持一定程度上的重复是有意义的，比如使代码更具语义化，让人更看得懂代码在干啥，这在 <code>class</code> 时代特别明显。在 <code>class</code> 时代能解决这一问题的办法就是 HOC，比如我们做<code>withLoading</code>、<code>withToggle</code>、<code>withRemoteData</code>等等……</p> <p>然后就会变成这样：</p> <p><img src="https://pic3.zhimg.com/80/v2-24e3764b9fb11a47e18be65f8426db93_720w.jpg" alt="img"></p> <p>好在 hook 能比较合理地去解决这种嵌套问题。</p> <h3 id="合理设计粒度"><a href="#合理设计粒度" aria-hidden="true" class="header-anchor">#</a> 合理设计粒度</h3> <p>本章讲了 2 个主要的论述：状态粒度太细不好，粒度太粗也不好。</p> <p>在实际的业务里，比这复杂的多的事情天天在发生，远不是太细了合一合、太粗了分一分这么简单，大部分时候我们面对的是这样的情况：</p> <p><img src="https://pic3.zhimg.com/80/v2-a2a4a2c5d0d50a193a6c70afa4878f7f_720w.jpg" alt="img"></p> <p>5 个状态 4 个组合操作，怎么设计粒度更合理，就慢慢折腾去吧。</p> <p>最后送一个本文中提到的行选中功能的完整实现：</p> <p><a href="https://link.zhihu.com/?target=https%3A//gist.github.com/otakustay/9b59153da2e124f0637732fef5c71c6a" target="_blank" rel="noopener noreferrer">useSelectiongist.github.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="一直都在的-ref"><a href="#一直都在的-ref" aria-hidden="true" class="header-anchor">#</a> 一直都在的 Ref</h2> <p><code>Ref</code> 自 React 之初就不离不弃，最远古的字符串：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token operator">&lt;</span>div ref<span class="token operator">==</span><span class="token string">&quot;root&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
</code></pre></div><p>到函数的形式：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> e<span class="token punctuation">)</span><span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><p>到 <code>createRef</code>：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  root <span class="token operator">=</span> <span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>到 <code>useRef</code>：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>root<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>useRef</code> 是 <code>hook</code> 一直绕不开的话题</p> <h3 id="dom-与坑"><a href="#dom-与坑" aria-hidden="true" class="header-anchor">#</a> DOM 与坑</h3> <p>最常见的 <code>useRef</code> 的用法就是保存一个 DOM 元素的引用，然后拿着 <code>useEffect</code> 去访问：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> text <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>width<span class="token punctuation">,</span> setWidth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>

  <span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setWidth</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>current<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>root<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>text<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">}</span>
</code></pre></div><p>一段很常见的，运行十分良好的代码，但是如果我们将需求做一些变化，比如增加一个 <code>visible: boolean</code> 属性，然后变成：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">return</span> visible <span class="token operator">?</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>root<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>text<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">:</span> <span class="token keyword">null</span>
</code></pre></div><p>将会发生什么呢？</p> <p>很遗憾的是，这个组件如果第一次渲染的时候就指定了 <code>visible={false}</code> 的话，是无法正常工作的，具体可以参考这个 Sandbox 的示例：https://link.zhihu.com/?target=https%3A//codesandbox.io/s/conditional-ref-and-effect-t3pmo</p> <p>这不仅仅存在于特定条件返回元素的情况之下，还包含了不少其他的场景：</p> <ol><li>根据条件返回不同的 DOM 元素，如 <code>div</code> 和 <code>span</code> 换着来</li> <li>返回的元素有 <code>key</code> 属性且会变化</li></ol> <p>熟悉 <code>useEffect</code> 的人可能会发现，这个不执行的原因无非是没有传递依赖给 <code>useEffect</code> 函数，那么如果我们将 <code>ref.current</code> 传递过去呢？</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token function">useLayoutEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>在一定的场景之下，比如上面的示例，这种方式是可行的，因为当 <code>ref.current</code> 变化的时候，代表着渲染的元素发生了变化，这个变化一定是由一次渲染引起的，也一定会触发对应的 <code>useEffect</code> 执行。但也存在不可行的时候，有些 DOM 的变化并非由渲染引起的，那么就不会有相应的 <code>useEffect</code> 被触发</p> <p>这是 <code>useRef</code> 的一个神奇之处，虽然从名字上来说它应当被广泛用于和 DOM 元素简历关联，但往往拿它和 DOM 元素关联存在被坑的场景</p> <h3 id="ref-的真实身份"><a href="#ref-的真实身份" aria-hidden="true" class="header-anchor">#</a> Ref 的真实身份</h3> <p>让我们回到 class 时代看看 <code>createRef</code> 的用法：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  root <span class="token operator">=</span> <span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> width<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">.</span>current<span class="token punctuation">.</span>offsetWidth <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>仔细观察一下，<code>createRef</code> 是被用在什么地方的：它被放在了类的实例属性上面</p> <p>由此得出，一个快速的结论：</p> <blockquote><p>ref 是一个与组件对应的 React 节点生命周期相同的，可用于存放自定义内容的容器</p></blockquote> <p>在 class 时代，由于㢟节点是通过 class 实例化而得，一次你可以在类实例上存放内容，这些内容随着实例化产生，随着 <code>componentWillUnmount</code> 销毁。但是在 hook 的范围下，函数组件并没有 <code>this</code> 和对应的实例，因此 <code>useRef</code> 作为这一能力的弥补，扮演者跨多次渲染存放内容的角色</p> <p><strong>每一个希望深入 hook 实践的开发者都必须记住这个结论，无法自如地使用 useRef 会让你失去 hook 将近一半的能力</strong></p> <h3 id="一个定时器"><a href="#一个定时器" aria-hidden="true" class="header-anchor">#</a> 一个定时器</h3> <p>在知晓了 ref 的真实身份之后，来看一个实际的例子，试图实现一个 <code>useInterval</code> 以定时执行函数：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">useInterval</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> time</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> tick <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>tick<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>fn<span class="token punctuation">,</span> time<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>这是一个基于 <code>useEffect</code> 的实现，如果你试图这样去使用它：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token function">useInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCounter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">counter</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> counter <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>你会发现和你预期的“每秒计数加一”不同，这个定时器执行频率会变得非常诡异。因为你传入的 <code>fn</code> 每一次都在变化，每一次都导致 <code>useEffect</code> 销毁前一个定时器，打开一个新的定时器，所以简而言之，如果 1 秒之内没有重新渲染，定时器会被执行，而如果有新的渲染，定时器会重头再来，这让频率变得不稳定</p> <p>为了修正频率的稳定性，我们可以要求使用者通过 <code>useCallback</code>将传入的 <code>fn</code> 固定起来，但是总有百密一疏，且这样的问题难以发现，此时我们可以拿出 <code>useRef</code> 换一种玩法：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">useTimeout</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> time</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> callback <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
  callback<span class="token punctuation">.</span>current <span class="token operator">=</span> fn
  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> tick <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>callback<span class="token punctuation">.</span>current<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>tick<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>time<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>把 <code>fn</code> 放进一个 <code>ref</code> 当中，它就可以绕过 <code>useEffect</code> 的闭包问题，让 <code>useEffect</code> 回调每一次都能拿到正确的、最新的函数，却不需要将它作为依赖导致定时器不稳定</p> <p>React 官方也曾写过一些说明这一现象的博客，它们称 <code>useRef</code> 为“ hook 中的作弊器”，我想这个形容是准确的，所谓的“作弊”，其实是指它打破了类似 <code>useCallback</code>、<code>useEffect</code> 对闭包的约束，使用一个“可变的容器”让 <code>ref</code> 不需要成为闭包的依赖也可以在闭包中获取最新的内容</p> <p>这也是 <a href="https://link.zhihu.com/?target=https%3A//github.com/ecomfe/react-hooks/tree/master/packages/timeout" target="_blank" rel="noopener noreferrer">@huse/timeout<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的具体实现，同时提供 <code>useTimeout</code> 和 <code>useInterval</code>，还附加一个 <code>useStableInterval</code> 会感知函数的执行时间（包括异步函数）并确保更加稳定的函数执行间隔</p> <p>除此之外，<a href="https://link.zhihu.com/?target=https%3A//github.com/ecomfe/react-hooks/tree/master/packages/poll" target="_blank" rel="noopener noreferrer">@huse/poll<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 随时一个更为智能的定时实现，能够根据用户对页面的关注状态选择不同的频率，非常适用于定时拉取数据的场景</p> <p><code>useRef</code> 因为其可变内容、与组件节点保持相同生命周期的特点，其实有非常多的奇妙用法</p> <h3 id="回调-ref"><a href="#回调-ref" aria-hidden="true" class="header-anchor">#</a> 回调 ref</h3> <p>为了解决 <code>useRef</code> 与 DOM 元素关联时的坑，最保守的方式就是使用函数作为 <code>ref</code>：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> text<span class="token punctuation">,</span> visible <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>width<span class="token punctuation">,</span> setWidth<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> element <span class="token operator">&amp;&amp;</span> <span class="token function">setWidth</span><span class="token punctuation">(</span>element<span class="token punctuation">.</span>offsetWidth<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> visible <span class="token operator">?</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>text<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><p>函数的 <code>ref</code> 一定会在元素生成或销毁时被执行，可以确保追踪到最新的 DOM 元素。但它依然有一个缺点，例如我们想要实现这样的一个功能：</p> <blockquote><p>任意一段文字，通过计时器循环每个字符变色</p></blockquote> <p>假设我们突发奇想，不用 <code>state</code> 去控制变色的字符，就可以写出类似代码：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token function">useEffect</span><span class="token punctuation">(</span>
	<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> element <span class="token operator">=</span> ref<span class="token punctuation">.</span>current<span class="token punctuation">;</span>
    <span class="token keyword">const</span> tick <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span>
    	<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      	<span class="token comment">// 循环取下一个字符变色</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token number">1000</span>
    <span class="token punctuation">)</span>；
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>tick<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这是经典的 <code>useEffect</code> 的使用方式，返回一个函数来销毁之前的副作用。但是之前说了，<code>useRef</code> 和 <code>useEffect</code> 的配合是存在坑的，我们需要改造成函数 <code>ref</code>， 但是函数 <code>ref</code> 不支持销毁......</p> <p>所以最后妥协了，依然使用 <code>useEffect</code>，但在渲染时确保只生成一个 DOM 元素，让 <code>useEffect</code> 一定能生效：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">return</span> <span class="token punctuation">(</span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span></span> <span class="token attr-name">style</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> display<span class="token punctuation">:</span> visible <span class="token operator">?</span> <span class="token string">''</span> <span class="token punctuation">:</span> <span class="token string">'none'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">
    </span><span class="token punctuation">{</span>text<span class="token punctuation">}</span><span class="token plain-text">
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span>
<span class="token punctuation">)</span>
</code></pre></div><p>在这个场景下这样是可以“绕过”问题，并最终产出有效可用的代码，但是换一个场景呢？</p> <blockquote><p>使用 JQuery LightBox 插件，对一个图片增加点击预览功能</p></blockquote> <p>现在我们面对的是一个 <code>img</code> 元素，在没有 <code>src</code> 的时候这东西可不是简单的 <code>display： none</code> 就能安分守己的，你不得不采取 <code>return null</code> 的形式解决问题，那么你依然会提上 <code>useEffect</code> 的局限性</p> <p>其实换个角度，我们缺少的是&quot;将销毁函数保留下来以待执行&quot;的功能，这是不是非常像 <code>useTimeout</code> 或者 <code>useInterval</code> 的功能呢？无非一个是延后一定时间执行，一个是延后到 DOM 元素销毁时执行</p> <p>也就是说，我们完全可以用 <code>useRef</code> 本身去保存一个销毁函数，来实现与 <code>useEffect</code> 等价的能力：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">noop</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> undefined

<span class="token keyword">const</span> <span class="token function-variable function">useEffectRef</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> disposeRef <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span>noop<span class="token punctuation">)</span>
  <span class="token keyword">const</span> effect <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      disposeRef<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token comment">// 确保这货只被调用一次，所以调用完就干掉</span>
      disposeRef<span class="token punctuation">.</span>current <span class="token operator">=</span> noop

      <span class="token keyword">if</span> <span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> dispose <span class="token operator">=</span> <span class="token function">callback</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> dispose <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          disposeRef<span class="token punctuation">.</span>current <span class="token operator">=</span> dispose
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dispose <span class="token operator">!==</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">'Effect ref callback must return undefined or a dispose function'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>callback<span class="token punctuation">]</span>
  <span class="token punctuation">)</span>
  <span class="token keyword">return</span> effect
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> visible<span class="token punctuation">,</span> text <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> colorful <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">element</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> tick <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token comment">// 循环取下一个字符变色</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">clearInterval</span><span class="token punctuation">(</span>tick<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useEffectRef</span><span class="token punctuation">(</span>colorful<span class="token punctuation">)</span>

  <span class="token keyword">return</span> visible <span class="token operator">?</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>ref<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>text<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，就是将之前的 <code>useEffect</code> 中的代码转移到了 <code>useEffectRef</code> 里（要用 <code>useCallback</code>包裹一下 ），代码很容易迁移，这算是 <code>useRef</code> 中的一个经典场景</p> <p>通过 <a href="https://link.zhihu.com/?target=https%3A//github.com/ecomfe/react-hooks/tree/master/packages/effect-ref" target="_blank" rel="noopener noreferrer">@huse/effect-ref<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 提供了 <code>useEffectRef</code> 能力，同时基于它在 <a href="https://link.zhihu.com/?target=https%3A//github.com/ecomfe/react-hooks/tree/master/packages/element-size" target="_blank" rel="noopener noreferrer">@huse/element-size<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中实现了 <code>useElement</code>、<code>useElementResize</code> 等 hook，能够有效提升业务开发的效率</p> <h2 id="玩坏-ref"><a href="#玩坏-ref" aria-hidden="true" class="header-anchor">#</a> 玩坏 Ref</h2> <p>现在我们知道了 <code>useRef</code> 到底是个什么东西，它可以生成一个与组件节点生命周期的存放可变内容的容器</p> <p>在这基础之上，可以使用 <code>useRef</code> 做很多东西</p> <h3 id="可变对象"><a href="#可变对象" aria-hidden="true" class="header-anchor">#</a> 可变对象</h3> <p>更新一个数组或对象，用不可变的方式还是比较容易的：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>oldObj<span class="token punctuation">,</span>
  foo<span class="token punctuation">:</span> newFoo<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是如果遇到 <code>Map</code> 和 <code>Set</code> 这类东西，它天生是可变的集合容器，如果这样写：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>items<span class="token punctuation">,</span> setItems<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> addItem <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setItem</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">items</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> items<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>其实并不会触发组件更新，因为 <code>items.add</code> 前后并没有发生引用的改变，对 React 而言是同一个东西</p> <p>一个办法是 <a href="https://link.zhihu.com/?target=https%3A//immerjs.github.io/immer/docs/complex-objects" target="_blank" rel="noopener noreferrer">immer 提供了针对 Map 和 Set 的更新<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，但是如果不想依赖 <code>immer</code> 该如何使用呢</p> <p>其实我们可以用 <code>useRef</code> 来管理这样一个可变的状态，再想办法在状态更新的时候触发渲染就好。为此，我们需要一个可以直接触发组件更新的手段，让组件更新最简单的办法就是改变一个状态，那什么样的状态是每一次都会变化的呢？</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">useForceUpdate</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre></div><p>就这样搞定了，一个简单的递增的数字就行，通过 <a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/%40huse/update" target="_blank" rel="noopener noreferrer">@huse/update<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 包中的 <code>useForceUpdate</code> 提供了这一能力</p> <p>再然后，把它们拼在一起试试：</p> <div class="language-tsx extra-class"><pre class="language-tsx"><code><span class="token keyword">const</span> <span class="token function-variable function">useSet</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">initialEntries</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>initialEntries<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> forceUpdate <span class="token operator">=</span> <span class="token function">useForceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> add <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      ref<span class="token punctuation">.</span>current<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
      <span class="token function">forceUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>forceUpdate<span class="token punctuation">]</span>
  <span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>ref<span class="token punctuation">.</span>current<span class="token punctuation">,</span> <span class="token punctuation">{</span> add <span class="token punctuation">}</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样一个简单的对 <code>Set</code> 的操作就实现了。**不过我还不是很确定在并发模式下这东西是靠谱的，有什么结论的同学可以回复讨论一下。**我们也通过<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/%40huse/collection" target="_blank" rel="noopener noreferrer">@huse/collection<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提供了<code>useArray</code>、<code>useMap</code>、<code>useSet</code>等一系列集合相关的功能。</p> <h3 id="渲染计数"><a href="#渲染计数" aria-hidden="true" class="header-anchor">#</a> 渲染计数</h3> <p>React 一个很让人头疼的问题是，它的性能是薛定谔的状态，哪怕脑子再清醒犀利，你也很难去判断一个组件在一顿操作猛如虎之下会更新几次、渲染几次，直到哪天性能崩得受不住了你才会回头捡起来看看情况。</p> <p>用 Chrome 的性能面板去看情况当然非常好非常专业，但其实成本也不小，录制、分析都挺花精力的。有时候我们只想看看一个组件到底渲染不渲染，渲染了几次，大致对性能有一个了解；或者就想研究一下实现的自定义 hook 会不会造成组件过多的更新，所以我们希望能有这样的东西：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> renderTimes <span class="token operator">=</span> <span class="token function">useRenderTimes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div title<span class="token operator">=</span><span class="token punctuation">{</span><span class="token template-string"><span class="token string">`Rendered </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>renderTimes<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> times`</span></span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">...</span>各种内容<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后操作一下，看看渲染次数有没有增长，快速地做一些定位和修复。</p> <p>那么怎么实现这个东西呢，如果用状态的话：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">useRenderTimes</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>times<span class="token punctuation">,</span> increment<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useReducer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> v <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 每次渲染的时候递增一下</span>
  <span class="token keyword">return</span> times
<span class="token punctuation">}</span>
</code></pre></div><p>试一试？试试就逝世，保管你的浏览器卡得死死的关都不一定关得掉。这种在渲染中调用状态更新无疑会触发下一次渲染，形成一个死循环。</p> <p>所以这时我们就要用到不会触发更新的可变容器：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">useRenderTimes</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> times <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
  times<span class="token punctuation">.</span>current<span class="token operator">++</span>
  <span class="token keyword">return</span> times<span class="token punctuation">.</span>current
<span class="token punctuation">}</span>
</code></pre></div><p>你看不仅仅不会触发更新了，代码也清晰直观了很多。在<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/%40huse/debug" target="_blank" rel="noopener noreferrer">@huse/debug<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>包中就有这个<code>useRenderTimes</code>，附带的还有很多用于调试的工具，不过要记得部署到生产环境前把这些代码去掉哦。</p> <h3 id="前一次值"><a href="#前一次值" aria-hidden="true" class="header-anchor">#</a> 前一次值</h3> <p>在 class 组件的时代，我们有不少方法是能拿到“前一次更新的值”的，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token comment">// 前一次的属性和状态全给了</span>
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> prevState<span class="token punctuation">,</span> snapshot</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// 这个反过来，给你下一次的，但this.props就是当前的了</span>
  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后到了函数组件的时候，一下子全没了，全没了……这可不是说需要的场景就真的消失了，场景多着呢。</p> <p>所以我们想办法把这个功能再找回来，原理也很简单，拿一个容器存着前一次的值不就好了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">usePreviousValue</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> previous <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> previousValue <span class="token operator">=</span> previous<span class="token punctuation">.</span>current
  previous<span class="token punctuation">.</span>current <span class="token operator">=</span> value
  <span class="token keyword">return</span> previousValue
<span class="token punctuation">}</span>
</code></pre></div><p>在<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/%40huse/previous-value" target="_blank" rel="noopener noreferrer">@huse/previous-value<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中就给了这个能力，除此之外你还可以判断这个值是不是变了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">usePreviousEquals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> deepEquals<span class="token punctuation">)</span> <span class="token comment">// 甚至还能自定义比较函数</span>
</code></pre></div><h3 id="组件更新源"><a href="#组件更新源" aria-hidden="true" class="header-anchor">#</a> 组件更新源</h3> <p>你可能会说，React 不给你原始值一定有它设计的原因的，我肯定可以不用原始值活着的！那就来看一个比较经典的场景。</p> <p>众所周知地再次强调，React 的更新和渲染基本就是个薛定谔状态，经常会有“你觉得我不会更新但我更新了呵呵呵”这样的尴尬情况出现，想知道组件为什么发生了更新是几乎每一个 React 开发者的渴望，甚至因此活生生出现了<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/%40welldone-software/why-did-you-render" target="_blank" rel="noopener noreferrer">why-did-you-update<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这种东西。</p> <p>不过<code>why-did-you-update</code>这东西的侵入性着实有些高，我们不如用 hook 来做一个简单的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">useUpdateCause</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> print</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> previousProps <span class="token operator">=</span> <span class="token function">usePreviousValue</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
  <span class="token keyword">const</span> differences <span class="token operator">=</span> <span class="token function">findDifferences</span><span class="token punctuation">(</span>previousProps<span class="token punctuation">,</span> props<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>print<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printUpdateCause</span><span class="token punctuation">(</span>differences<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> differences
<span class="token punctuation">}</span>
</code></pre></div><p>通过简单地将当前值与上一次值比较来找到变化的原因，甚至可以做更精确地判断，比如<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/%40huse/debug" target="_blank" rel="noopener noreferrer">@huse/debug<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中的 <code>useUpdateCause</code>就可以打印出这样的表格：</p> <div class="language-text extra-class"><pre class="language-text"><code>-----------------------------------------------------------------------
| (index) | previousValue | currentValue | shallowEquals | deepEquals |
-----------------------------------------------------------------------
|   foo   |    [Object]   |   [Object]   |     true      |    true    |
|   bar   |      1234     |     5678     |     true      |    true    |
-----------------------------------------------------------------------
</code></pre></div><p>帮助你一目了然地知道这些属性怎么变化。</p> <h3 id="对象追回"><a href="#对象追回" aria-hidden="true" class="header-anchor">#</a> 对象追回</h3> <p>如果你通过<code>useUpdateCause</code>找到了一个属性变化，它虽然引用发生了变化，但是<code>deepEquals</code>列告诉你其实内容是一模一样的，这个变化完全不需要发生，要怎么办呢？</p> <p>为了整个应用着想，我们会试图去追溯这个属性怎么来的，是不是在什么地方缺了<code>useMemo</code>或者<code>reselect</code>跨组件实例用了，没有做好缓存等等。但更多的时候，我们会发现外部的属性完全不是我们可控的，甚至可能来自于后端的返回，无论如何也做不到引用相同。</p> <p>如果仅仅是触发了多次的更新，有些微的性能的损耗是小事，但如果这东西你用在了<code>useEffect</code>上，那可就要命了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">useEffect</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/users'</span><span class="token punctuation">,</span> params<span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> response<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">list</span> <span class="token operator">=&gt;</span> <span class="token function">setUserList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>params<span class="token punctuation">]</span> <span class="token comment">// 这东西要是引用不同怎么活</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>动不动就无限发请求，等着后端提刀子上门问候，这可不好。</p> <p>我们要承认，这种情况在 React 生态里是随处可见的，甚至<a href="https://link.zhihu.com/?target=https%3A//gist.github.com/slikts/fd3768de1493419ed9506002b452fcdc" target="_blank" rel="noopener noreferrer">有为此而生的讨论串<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。有些开发者“机智”地用<code>JSON.stringify</code>去解决问题：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> paramsString <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">useEffect</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> params <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>paramsString<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>paramsString<span class="token punctuation">]</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这是有多蛋疼呢：</p> <ol><li>用<code>JSON.stringify</code>本身就消耗了性能，性能还不一定低于一次渲染。</li> <li>为了躲 ESLint 的规则检查，再用<code>JSON.parse</code>转回来，再消耗一次性能。</li> <li>我还没说<code>JSON.stringify</code>对属性是不排序的，这样搞依然有可能出现内容相同但<code>paramString</code>不同的情况，你还得用<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/fast-json-stable-stringify" target="_blank" rel="noopener noreferrer">fast-json-stable-stringify<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这样的库帮你解决问题。</li></ol> <p>所以在此我要展示一个神奇的 hook：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">useOriginalCopy</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> equals <span class="token operator">=</span> shallowEquals</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">equals</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span>current<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> cache<span class="token punctuation">.</span>current
  <span class="token punctuation">}</span>

  cache<span class="token punctuation">.</span>current <span class="token operator">=</span> value
  <span class="token keyword">return</span> value
<span class="token punctuation">}</span>
</code></pre></div><p>它到底干嘛了呢？简单来说就是“上一次的值与这一次内容相同的话，就把上一次还给你好啦”。这样就能把最原始的那个引用都一样的对象给拿到手了：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> originalPrams <span class="token operator">=</span> <span class="token function">useOriginalCopy</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> deepEquals<span class="token punctuation">)</span> <span class="token comment">// 用深比较</span>
<span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>originalPrams<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p>这样就能妥妥地安全使用。我们在<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/%40huse/previous-value" target="_blank" rel="noopener noreferrer">@huse/previous-value<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>里提供了这个能力，我愿意称之为我在 hook 领域上最伟大的发明，在社区上还没见过类似的实现。</p> <p>使用<code>useRef</code>能实现的功能还有很多，比如<a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/%40huse/derived-state" target="_blank" rel="noopener noreferrer">@huse/derived-state<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>能实现<code>getDerivedStateFromProps</code>的效果等等，学会使用它会给 React 领域的开发带来很大的便利和帮助。</p> <h2 id="看完后的学习目标"><a href="#看完后的学习目标" aria-hidden="true" class="header-anchor">#</a> 看完后的学习目标</h2> <p>和学习 <code>lodash</code> 一样，在项目中引入 <a href="https://github.com/ecomfe/react-hooks" target="_blank" rel="noopener noreferrer">@huse<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 并熟练使用它</p> <p>通过 熟练使用 =&gt; 设计轮子 =&gt; 参考比对 =&gt; 自我实现 的路径去深度掌握</p></div> <footer class="page-edit" style="display:none;"><div class="edit-link"><a href="https://github.com/hentai-miao/blog-vuepress/edit/master/docs/frontEnd/react/react02.md" target="_blank" rel="noopener noreferrer">编辑此页面</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最终更新于: </span> <span class="time">9/7/2020, 7:25:11 PM</span></div></footer> <!----> <!----> <!----></main> <!----></div></div></div></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.f09e1a8f.js" defer></script><script src="/assets/js/3.6380eba5.js" defer></script><script src="/assets/js/1.86ff7d31.js" defer></script><script src="/assets/js/84.91f0b5d9.js" defer></script>
  </body>
</html>
