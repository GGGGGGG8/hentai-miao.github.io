(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{536:function(e,n,r){"use strict";r.r(n);var t=r(4),s=Object(t.a)({},function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"前言"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),r("p",[e._v("Promise 的基本使用可以看阮一峰老师的 "),r("a",{attrs:{href:"http://es6.ruanyifeng.com/#docs/promise",target:"_blank",rel:"noopener noreferrer"}},[e._v("《ECMAScript 6 入门》"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("p",[e._v("我们来聊点其他的。")]),e._v(" "),r("h2",{attrs:{id:"回调"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回调","aria-hidden":"true"}},[e._v("#")]),e._v(" 回调")]),e._v(" "),r("p",[e._v("说起 Promise，我们一般都会从回调或者回调地狱说起，那么使用回调到底会导致哪些不好的地方呢？")]),e._v(" "),r("h3",{attrs:{id:"_1-回调嵌套"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-回调嵌套","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. 回调嵌套")]),e._v(" "),r("p",[e._v("使用回调，我们很有可能会将业务代码写成如下这种形式：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("doA( function(){\n    doB();\n\n    doC( function(){\n        doD();\n    } )\n\n    doE();\n} );\n\ndoF();\n复制代码\n")])])]),r("p",[e._v("当然这是一种简化的形式，经过一番简单的思考，我们可以判断出执行的顺序为：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("doA()\ndoF()\ndoB()\ndoC()\ndoE()\ndoD()\n复制代码\n")])])]),r("p",[e._v("然而在实际的项目中，代码会更加杂乱，为了排查问题，我们需要绕过很多碍眼的内容，不断的在函数间进行跳转，使得排查问题的难度也在成倍增加。")]),e._v(" "),r("p",[e._v("当然之所以导致这个问题，其实是因为这种嵌套的书写方式跟人线性的思考方式相违和，以至于我们要多花一些精力去思考真正的执行顺序，嵌套和缩进只是这个思考过程中转移注意力的细枝末节而已。")]),e._v(" "),r("p",[e._v("当然了，与人线性的思考方式相违和，还不是最糟糕的，实际上，我们还会在代码中加入各种各样的逻辑判断，就比如在上面这个例子中，doD() 必须在 doC() 完成后才能完成，万一 doC() 执行失败了呢？我们是要重试 doC() 吗？还是直接转到其他错误处理函数中？当我们将这些判断都加入到这个流程中，很快代码就会变得非常复杂，以至于无法维护和更新。")]),e._v(" "),r("h3",{attrs:{id:"_2-控制反转"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-控制反转","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. 控制反转")]),e._v(" "),r("p",[e._v("正常书写代码的时候，我们理所当然可以控制自己的代码，然而当我们使用回调的时候，这个回调函数是否能接着执行，其实取决于使用回调的那个 API，就比如：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 回调函数是否被执行取决于 buy 模块\nimport {buy} from './buy.js';\n\nbuy(itemData, function(res) {\n    console.log(res)\n});\n复制代码\n")])])]),r("p",[e._v("对于我们经常会使用的 fetch 这种 API，一般是没有什么问题的，但是如果我们使用的是第三方的 API 呢？")]),e._v(" "),r("p",[e._v("当你调用了第三方的 API，对方是否会因为某个错误导致你传入的回调函数执行了多次呢？")]),e._v(" "),r("p",[e._v("为了避免出现这样的问题，你可以在自己的回调函数中加入判断，可是万一又因为某个错误这个回调函数没有执行呢？ 万一这个回调函数有时同步执行有时异步执行呢？")]),e._v(" "),r("p",[e._v("我们总结一下这些情况：")]),e._v(" "),r("ol",[r("li",[e._v("回调函数执行多次")]),e._v(" "),r("li",[e._v("回调函数没有执行")]),e._v(" "),r("li",[e._v("回调函数有时同步执行有时异步执行")])]),e._v(" "),r("p",[e._v("对于这些情况，你可能都要在回调函数中做些处理，并且每次执行回调函数的时候都要做些处理，这就带来了很多重复的代码。")]),e._v(" "),r("h2",{attrs:{id:"回调地狱"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回调地狱","aria-hidden":"true"}},[e._v("#")]),e._v(" 回调地狱")]),e._v(" "),r("p",[e._v("我们先看一个简单的回调地狱的示例。")]),e._v(" "),r("p",[e._v("现在要找出一个目录中最大的文件，处理步骤应该是：")]),e._v(" "),r("ol",[r("li",[e._v("用 "),r("code",[e._v("fs.readdir")]),e._v(" 获取目录中的文件列表；")]),e._v(" "),r("li",[e._v("循环遍历文件，使用 "),r("code",[e._v("fs.stat")]),e._v(" 获取文件信息")]),e._v(" "),r("li",[e._v("比较找出最大文件；")]),e._v(" "),r("li",[e._v("以最大文件的文件名为参数调用回调。")])]),e._v(" "),r("p",[e._v("代码为：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var fs = require('fs');\nvar path = require('path');\n\nfunction findLargest(dir, cb) {\n    // 读取目录下的所有文件\n    fs.readdir(dir, function(er, files) {\n        if (er) return cb(er);\n\n        var counter = files.length;\n        var errored = false;\n        var stats = [];\n\n        files.forEach(function(file, index) {\n            // 读取文件信息\n            fs.stat(path.join(dir, file), function(er, stat) {\n\n                if (errored) return;\n\n                if (er) {\n                    errored = true;\n                    return cb(er);\n                }\n\n                stats[index] = stat;\n\n                // 事先算好有多少个文件，读完 1 个文件信息，计数减 1，当为 0 时，说明读取完毕，此时执行最终的比较操作\n                if (--counter == 0) {\n\n                    var largest = stats\n                        .filter(function(stat) { return stat.isFile() })\n                        .reduce(function(prev, next) {\n                            if (prev.size > next.size) return prev\n                            return next\n                        })\n\n                    cb(null, files[stats.indexOf(largest)])\n                }\n            })\n        })\n    })\n}\n复制代码\n")])])]),r("p",[e._v("使用方式为：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 查找当前目录最大的文件\nfindLargest('./', function(er, filename) {\n    if (er) return console.error(er)\n    console.log('largest file was:', filename)\n});\n复制代码\n")])])]),r("p",[e._v("你可以将以上代码复制到一个比如 "),r("code",[e._v("index.js")]),e._v(" 文件，然后执行 "),r("code",[e._v("node index.js")]),e._v(" 就可以打印出最大的文件的名称。")]),e._v(" "),r("p",[e._v("看完这个例子，我们再来聊聊回调地狱的其他问题：")]),e._v(" "),r("p",[r("strong",[e._v("1.难以复用")])]),e._v(" "),r("p",[e._v("回调的顺序确定下来之后，想对其中的某些环节进行复用也很困难，牵一发而动全身。")]),e._v(" "),r("p",[e._v("举个例子，如果你想对 "),r("code",[e._v("fs.stat")]),e._v(" 读取文件信息这段代码复用，因为回调中引用了外层的变量，提取出来后还需要对外层的代码进行修改。")]),e._v(" "),r("p",[r("strong",[e._v("2.堆栈信息被断开")])]),e._v(" "),r("p",[e._v("我们知道，JavaScript 引擎维护了一个执行上下文栈，当函数执行的时候，会创建该函数的执行上下文压入栈中，当函数执行完毕后，会将该执行上下文出栈。")]),e._v(" "),r("p",[e._v("如果 A 函数中调用了 B 函数，JavaScript 会先将 A 函数的执行上下文压入栈中，再将 B 函数的执行上下文压入栈中，当 B 函数执行完毕，将 B 函数执行上下文出栈，当 A 函数执行完毕后，将 A 函数执行上下文出栈。")]),e._v(" "),r("p",[e._v("这样的好处在于，我们如果中断代码执行，可以检索完整的堆栈信息，从中获取任何我们想获取的信息。")]),e._v(" "),r("p",[e._v("可是异步回调函数并非如此，比如执行 "),r("code",[e._v("fs.readdir")]),e._v(" 的时候，其实是将回调函数加入任务队列中，代码继续执行，直至主线程完成后，才会从任务队列中选择已经完成的任务，并将其加入栈中，此时栈中只有这一个执行上下文，如果回调报错，也无法获取调用该异步操作时的栈中的信息，不容易判定哪里出现了错误。")]),e._v(" "),r("p",[e._v("此外，因为是异步的缘故，使用 try catch 语句也无法直接捕获错误。")]),e._v(" "),r("p",[e._v("(不过 Promise 并没有解决这个问题)")]),e._v(" "),r("p",[r("strong",[e._v("3.借助外层变量")])]),e._v(" "),r("p",[e._v("当多个异步计算同时进行，比如这里遍历读取文件信息，由于无法预期完成顺序，必须借助外层作用域的变量，比如这里的 count、errored、stats 等，不仅写起来麻烦，而且如果你忽略了文件读取错误时的情况，不记录错误状态，就会接着读取其他文件，造成无谓的浪费。此外外层的变量，也可能被其它同一作用域的函数访问并且修改，容易造成误操作。")]),e._v(" "),r("p",[r("strong",[e._v("之所以单独讲讲回调地狱，其实是想说嵌套和缩进只是回调地狱的一个梗而已，它导致的问题远非嵌套导致的可读性降低而已。")])]),e._v(" "),r("h2",{attrs:{id:"promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise")]),e._v(" "),r("p",[e._v("Promise 使得以上绝大部分的问题都得到了解决。")]),e._v(" "),r("h3",{attrs:{id:"_1-嵌套问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-嵌套问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. 嵌套问题")]),e._v(" "),r("p",[e._v("举个例子：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("request(url, function(err, res, body) {\n    if (err) handleError(err);\n    fs.writeFile('1.txt', body, function(err) {\n        request(url2, function(err, res, body) {\n            if (err) handleError(err)\n        })\n    })\n});\n复制代码\n")])])]),r("p",[e._v("使用 Promise 后：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("request(url)\n.then(function(result) {\n    return writeFileAsynv('1.txt', result)\n})\n.then(function(result) {\n    return request(url2)\n})\n.catch(function(e){\n    handleError(e)\n});\n复制代码\n")])])]),r("p",[e._v("而对于读取最大文件的那个例子，我们使用 promise 可以简化为：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var fs = require('fs');\nvar path = require('path');\n\nvar readDir = function(dir) {\n    return new Promise(function(resolve, reject) {\n        fs.readdir(dir, function(err, files) {\n            if (err) reject(err);\n            resolve(files)\n        })\n    })\n}\n\nvar stat = function(path) {\n    return new Promise(function(resolve, reject) {\n        fs.stat(path, function(err, stat) {\n            if (err) reject(err)\n            resolve(stat)\n        })\n    })\n}\n\nfunction findLargest(dir) {\n    return readDir(dir)\n        .then(function(files) {\n            let promises = files.map(file => stat(path.join(dir, file)))\n            return Promise.all(promises).then(function(stats) {\n                return { stats, files }\n            })\n        })\n        .then(data => {\n\n            let largest = data.stats\n                .filter(function(stat) { return stat.isFile() })\n                .reduce((prev, next) => {\n                    if (prev.size > next.size) return prev\n                    return next\n                })\n\n            return data.files[data.stats.indexOf(largest)]\n        })\n\n}\n复制代码\n")])])]),r("h3",{attrs:{id:"_2-控制反转再反转"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-控制反转再反转","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. 控制反转再反转")]),e._v(" "),r("p",[e._v("前面我们讲到使用第三方回调 API 的时候，可能会遇到如下问题：")]),e._v(" "),r("ol",[r("li",[e._v("回调函数执行多次")]),e._v(" "),r("li",[e._v("回调函数没有执行")]),e._v(" "),r("li",[e._v("回调函数有时同步执行有时异步执行")])]),e._v(" "),r("p",[e._v("对于第一个问题，Promise 只能 resolve 一次，剩下的调用都会被忽略。")]),e._v(" "),r("p",[e._v("对于第二个问题，我们可以使用 Promise.race 函数来解决：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('function timeoutPromise(delay) {\n    return new Promise( function(resolve,reject){\n        setTimeout( function(){\n            reject( "Timeout!" );\n        }, delay );\n    } );\n}\n\nPromise.race( [\n    foo(),\n    timeoutPromise( 3000 )\n] )\n.then(function(){}, function(err){});\n复制代码\n')])])]),r("p",[e._v("对于第三个问题，为什么有的时候会同步执行有的时候回异步执行呢？")]),e._v(" "),r("p",[e._v("我们来看个例子：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var cache = {...};\nfunction downloadFile(url) {\n      if(cache.has(url)) {\n            // 如果存在cache，这里为同步调用\n           return Promise.resolve(cache.get(url));\n      }\n     return fetch(url).then(file => cache.set(url, file)); // 这里为异步调用\n}\nconsole.log('1');\ngetValue.then(() => console.log('2'));\nconsole.log('3');\n复制代码\n")])])]),r("p",[e._v("在这个例子中，有 cahce 的情况下，打印结果为 1 2 3，在没有 cache 的时候，打印结果为 1 3 2。")]),e._v(" "),r("p",[e._v("然而如果将这种同步和异步混用的代码作为内部实现，只暴露接口给外部调用，调用方由于无法判断是到底是异步还是同步状态，影响程序的可维护性和可测试性。")]),e._v(" "),r("p",[e._v("简单来说就是同步和异步共存的情况无法保证程序逻辑的一致性。")]),e._v(" "),r("p",[e._v("然而 Promise 解决了这个问题，我们来看个例子：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var promise = new Promise(function (resolve){\n    resolve();\n    console.log(1);\n});\npromise.then(function(){\n    console.log(2);\n});\nconsole.log(3);\n\n// 1 3 2\n复制代码\n")])])]),r("p",[e._v("即使 promise 对象立刻进入 resolved 状态，即同步调用 resolve 函数，then 函数中指定的方法依然是异步进行的。")]),e._v(" "),r("p",[e._v("PromiseA+ 规范也有明确的规定：")]),e._v(" "),r("blockquote",[r("p",[e._v("实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。")])]),e._v(" "),r("h2",{attrs:{id:"promise-反模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-反模式","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise 反模式")]),e._v(" "),r("p",[r("strong",[e._v("1.Promise 嵌套")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// bad\nloadSomething().then(function(something) {\n    loadAnotherthing().then(function(another) {\n        DoSomethingOnThem(something, another);\n    });\n});\n复制代码\n// good\nPromise.all([loadSomething(), loadAnotherthing()])\n.then(function ([something, another]) {\n    DoSomethingOnThem(...[something, another]);\n});\n复制代码\n")])])]),r("p",[r("strong",[e._v("2.断开的 Promise 链")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// bad\nfunction anAsyncCall() {\n    var promise = doSomethingAsync();\n    promise.then(function() {\n        somethingComplicated();\n    });\n\n    return promise;\n}\n复制代码\n// good\nfunction anAsyncCall() {\n    var promise = doSomethingAsync();\n    return promise.then(function() {\n        somethingComplicated()\n    });\n}\n复制代码\n")])])]),r("p",[r("strong",[e._v("3.混乱的集合")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// bad\nfunction workMyCollection(arr) {\n    var resultArr = [];\n    function _recursive(idx) {\n        if (idx >= resultArr.length) return resultArr;\n\n        return doSomethingAsync(arr[idx]).then(function(res) {\n            resultArr.push(res);\n            return _recursive(idx + 1);\n        });\n    }\n\n    return _recursive(0);\n}\n复制代码\n")])])]),r("p",[e._v("你可以写成：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function workMyCollection(arr) {\n    return Promise.all(arr.map(function(item) {\n        return doSomethingAsync(item);\n    }));\n}\n复制代码\n")])])]),r("p",[e._v("如果你非要以队列的形式执行，你可以写成：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function workMyCollection(arr) {\n    return arr.reduce(function(promise, item) {\n        return promise.then(function(result) {\n            return doSomethingAsyncWithResult(item, result);\n        });\n    }, Promise.resolve());\n}\n复制代码\n")])])]),r("p",[r("strong",[e._v("4.catch")])]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// bad\nsomethingAync.then(function() {\n    return somethingElseAsync();\n}, function(err) {\n    handleMyError(err);\n});\n复制代码\n")])])]),r("p",[e._v("如果 somethingElseAsync 抛出错误，是无法被捕获的。你可以写成：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// good\nsomethingAsync\n.then(function() {\n    return somethingElseAsync()\n})\n.then(null, function(err) {\n    handleMyError(err);\n});\n复制代码\n// good\nsomethingAsync()\n.then(function() {\n    return somethingElseAsync();\n})\n.catch(function(err) {\n    handleMyError(err);\n});\n复制代码\n")])])]),r("h2",{attrs:{id:"红绿灯问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#红绿灯问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 红绿灯问题")]),e._v(" "),r("p",[e._v("题目：红灯三秒亮一次，绿灯一秒亮一次，黄灯2秒亮一次；如何让三个灯不断交替重复亮灯？（用 Promse 实现）")]),e._v(" "),r("p",[e._v("三个亮灯函数已经存在：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function red(){\n    console.log('red');\n}\nfunction green(){\n    console.log('green');\n}\nfunction yellow(){\n    console.log('yellow');\n}\n复制代码\n")])])]),r("p",[e._v("利用 then 和递归实现：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function red(){\n    console.log('red');\n}\nfunction green(){\n    console.log('green');\n}\nfunction yellow(){\n    console.log('yellow');\n}\n\nvar light = function(timmer, cb){\n    return new Promise(function(resolve, reject) {\n        setTimeout(function() {\n            cb();\n            resolve();\n        }, timmer);\n    });\n};\n\nvar step = function() {\n    Promise.resolve().then(function(){\n        return light(3000, red);\n    }).then(function(){\n        return light(2000, green);\n    }).then(function(){\n        return light(1000, yellow);\n    }).then(function(){\n        step();\n    });\n}\n\nstep();\n复制代码\n")])])]),r("h2",{attrs:{id:"promisify"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promisify","aria-hidden":"true"}},[e._v("#")]),e._v(" promisify")]),e._v(" "),r("p",[e._v("有的时候，我们需要将 callback 语法的 API 改造成 Promise 语法，为此我们需要一个 promisify 的方法。")]),e._v(" "),r("p",[e._v("因为 callback 语法传参比较明确，最后一个参数传入回调函数，回调函数的第一个参数是一个错误信息，如果没有错误，就是 null，所以我们可以直接写出一个简单的 promisify 方法：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function promisify(original) {\n    return function (...args) {\n        return new Promise((resolve, reject) => {\n            args.push(function callback(err, ...values) {\n                if (err) {\n                    return reject(err);\n                }\n                return resolve(...values)\n            });\n            original.call(this, ...args);\n        });\n    };\n}\n复制代码\n")])])]),r("p",[e._v("完整的可以参考 "),r("a",{attrs:{href:"https://github.com/digitaldesignlabs/es6-promisify/blob/master/lib/promisify.js",target:"_blank",rel:"noopener noreferrer"}},[e._v("es6-promisif"),r("OutboundLink")],1)]),e._v(" "),r("h2",{attrs:{id:"promise-的局限性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-的局限性","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise 的局限性")]),e._v(" "),r("h3",{attrs:{id:"_1-错误被吃掉"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-错误被吃掉","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. 错误被吃掉")]),e._v(" "),r("p",[e._v("首先我们要理解，什么是错误被吃掉，是指错误信息不被打印吗？")]),e._v(" "),r("p",[e._v("并不是，举个例子：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("throw new Error('error');\nconsole.log(233333);\n复制代码\n")])])]),r("p",[e._v("在这种情况下，因为 throw error 的缘故，代码被阻断执行，并不会打印 233333，再举个例子：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("const promise = new Promise(null);\nconsole.log(233333);\n复制代码\n")])])]),r("p",[e._v("以上代码依然会被阻断执行，这是因为如果通过无效的方式使用 Promise，并且出现了一个错误阻碍了正常 Promise 的构造，结果会得到一个立刻跑出的异常，而不是一个被拒绝的 Promise。")]),e._v(" "),r("p",[e._v("然而再举个例子：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let promise = new Promise(() => {\n    throw new Error('error')\n});\nconsole.log(2333333);\n复制代码\n")])])]),r("p",[e._v("这次会正常的打印 "),r("code",[e._v("233333")]),e._v("，说明 Promise 内部的错误不会影响到 Promise 外部的代码，而这种情况我们就通常称为 “吃掉错误”。")]),e._v(" "),r("p",[e._v("其实这并不是 Promise 独有的局限性，try..catch 也是这样，同样会捕获一个异常并简单的吃掉错误。")]),e._v(" "),r("p",[e._v("而正是因为错误被吃掉，Promise 链中的错误很容易被忽略掉，这也是为什么会一般推荐在 Promise 链的最后添加一个 catch 函数，因为对于一个没有错误处理函数的 Promise 链，任何错误都会在链中被传播下去，直到你注册了错误处理函数。")]),e._v(" "),r("h3",{attrs:{id:"_2-单一值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-单一值","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. 单一值")]),e._v(" "),r("p",[e._v("Promise 只能有一个完成值或一个拒绝原因，然而在真实使用的时候，往往需要传递多个值，一般做法都是构造一个对象或数组，然后再传递，then 中获得这个值后，又会进行取值赋值的操作，每次封装和解封都无疑让代码变得笨重。")]),e._v(" "),r("p",[e._v("说真的，并没有什么好的方法，建议是使用 ES6 的解构赋值：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Promise.all([Promise.resolve(1), Promise.resolve(2)])\n.then(([x, y]) => {\n    console.log(x, y);\n});\n复制代码\n")])])]),r("h3",{attrs:{id:"_3-无法取消"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-无法取消","aria-hidden":"true"}},[e._v("#")]),e._v(" 3. 无法取消")]),e._v(" "),r("p",[e._v("Promise 一旦新建它就会立即执行，无法中途取消。")]),e._v(" "),r("h3",{attrs:{id:"_4-无法得知-pending-状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-无法得知-pending-状态","aria-hidden":"true"}},[e._v("#")]),e._v(" 4. 无法得知 pending 状态")]),e._v(" "),r("p",[e._v("当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。")]),e._v(" "),r("h2",{attrs:{id:"手写-promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#手写-promise","aria-hidden":"true"}},[e._v("#")]),e._v(" 手写 Promise")]),e._v(" "),r("h3",{attrs:{id:"一、promise-是一个异步操作返回的对象-用来传递异步操作的消息。"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、promise-是一个异步操作返回的对象-用来传递异步操作的消息。","aria-hidden":"true"}},[e._v("#")]),e._v(" 一、Promise 是一个异步操作返回的对象，用来传递异步操作的消息。")]),e._v(" "),r("h4",{attrs:{id:"promise-介绍和使用详见-认识并使用-promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#promise-介绍和使用详见-认识并使用-promise","aria-hidden":"true"}},[e._v("#")]),e._v(" Promise 介绍和使用详见： "),r("a",{attrs:{href:"https://juejin.im/post/5aae38c951882577b45ecce0",target:"_blank",rel:"noopener noreferrer"}},[e._v("认识并使用 Promise"),r("OutboundLink")],1)]),e._v(" "),r("h3",{attrs:{id:"二、根据自己对-promise-的理解-实现一个promise"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、根据自己对-promise-的理解-实现一个promise","aria-hidden":"true"}},[e._v("#")]),e._v(" 二、根据自己对 Promise 的理解，实现一个Promise :")]),e._v(" "),r("p",[e._v("Promise 有三种状态：Pending 初始态； Fulfilled 成功态； Rejected 失败态。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function Promise(executor) {\n    let self = this;\n    self.status = 'pending'; //等待态\n    self.value = undefined;  //成功的返回值\n    self.reason = undefined; //失败的原因\n\n    function resolve(value){\n        if(self.status === 'pending'){\n            self.status = 'resolved';\n            self.value = value;\n        }\n    }\n    function reject(reason) {\n        if(self.status === 'pending') {\n            self.status = 'rejected';\n            self.reason = reason;\n        }\n    }\n    try{\n        executor(resolve, reject);\n    }catch(e){\n        reject(e);// 捕获时发生异常，就直接失败\n    }\n}\n//onFufiled 成功的回调\n//onRejected 失败的回调\nPromise.prototype.then = function (onFufiled, onRejected) {\n    let self = this;\n    if(self.status === 'resolved'){\n        onFufiled(self.value);\n    }\n    if(self.status === 'rejected'){\n        onRejected(self.reason);\n    }\n}\nmodule.exports = Promise;\n复制代码\n")])])]),r("h4",{attrs:{id:"来-测试一下子"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#来-测试一下子","aria-hidden":"true"}},[e._v("#")]),e._v(" 来 测试一下子：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let Promise = require('./Promise');\n\nlet promise = new Promise(function (resolve, reject) {\n    resolve(100);\n})\n\npromise.then(function (data) {\n    console.log('data:', data);\n},function (err) {\n    console.log('err:', err);\n})\n复制代码\n")])])]),r("blockquote",[r("p",[e._v("输出：data: 100")])]),e._v(" "),r("p",[e._v("^ _ ^ 测试成功啦 鼓掌鼓掌 ~")]),e._v(" "),r("p",[e._v("Promise 实例可以多次then，当成功后会将 then 中的成功方法按顺序执行，我们可以先将 then 中成功的回调和失败的回调存到数组内。当成功的时候调用成功的数组即可。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("self.onResolvedCallbacks = [];  /* 存放then成功的回调*/\nself.onRejectedCallbacks = [];  /* 存放then失败的回调*/\nfunction resolve(value){\n    if(self.status === 'pending'){\n        self.status = 'resolved';\n        self.value = value;\n        self.onResolvedCallbacks.forEach(function (fn) {\n            fn();\n        })\n    }\n}\nfunction reject(reason) {\n    if(self.status === 'pending') {\n        self.status = 'rejected';\n        self.reason = reason;\n        self.onRejectedCallbacks.forEach(function (fn) {\n            fn();\n        })\n    }\n}\n\n复制代码\nif(self.status === 'pending'){\n    self.onResolvedCallbacks.push(function () {\n        onFufiled(self.value);\n    })\n    self.onRejectedCallbacks.push(function () {\n        onRejected(self.reason);\n    })\n}\n复制代码\n")])])]),r("h3",{attrs:{id:"三、实现链式调用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、实现链式调用","aria-hidden":"true"}},[e._v("#")]),e._v(" 三、实现链式调用：")]),e._v(" "),r("p",[e._v("众所周知 Promise 的一大特点，就是链式调用。而 Promise 实现链式调用就是通过 then 方法返回一个新的 Promise。")]),e._v(" "),r("p",[e._v("如果第一个 then 中返回了一个结果，会将 Promise 的结果继续传给下一个 then 中；如果有错误则走下一个 then 的失败。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 添加 resolvePromise 方法 处理链式调用问题\nfunction resolvePromise(p2, x, resolve, reject) {\n    if(p2 === x){\n        return reject(new TypeError('循环引用'));\n    }\n    if(x!==null || (typeof x === 'object' || typeof x === 'function')){\n        try{\n            let then = x.then;\n            if(typeof then === 'function'){\n                then.call(x, function (y) {\n                    resolvePromise(promise2, y, resolve, reject);\n                },function (err) {\n                    reject(err);\n                });\n            }else{\n                resolve(x);\n            }\n        }catch(e){\n            reject(e);\n        }\n    }else{\n        resolve(x);\n    }\n}\n")])])]),r("h2",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#","aria-hidden":"true"}},[e._v("#")])]),e._v(" "),r("h2",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考","aria-hidden":"true"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),r("ol",[r("li",[e._v("《你不知道的 JavaScript 中卷》")]),e._v(" "),r("li",[r("a",{attrs:{href:"https://segmentfault.com/l/1500000008757392",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise 的 N 种用法"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://liubin.org/promises-book/#promise-done",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript Promise 迷你书"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"http://www.ituring.com.cn/article/66566",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promises/A+规范 "),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://www.cnblogs.com/ZHONGZHENHUA/p/8486616.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Promise 如何使用"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("RouterLink",{attrs:{to:"/frontEnd/es6/taoofcode.net/promise-anti-patterns/"}},[e._v("Promise Anti-patterns")])],1)])])},[],!1,null,null,null);n.default=s.exports}}]);